<%= javascript_include_tag 'three.js' %>
<script>
var scene, camera, renderer;
var geometry, material, mesh;
var pyramid, dir_light,visited = [];

init();


function init() {

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.set(0,100,0);
    camera.lookAt(scene.position);

    var light = new THREE.PointLight( 0xFFFFFF, 0.5, 100 );
    light.position.set(0,0,0 );
    scene.add( light );
    

    dir_light = new THREE.DirectionalLight( 0xffd700 );
    dir_light.position.set( 20, 30, -5 );
    dir_light.target.position.copy( scene.position );
    dir_light.castShadow = true;
    dir_light.shadowCameraLeft = -100;
    dir_light.shadowCameraTop = -100;
    dir_light.shadowCameraRight = 100;
    dir_light.shadowCameraBottom = 100;
    dir_light.shadowCameraNear = 0;
    dir_light.shadowCameraFar = 100;
    dir_light.shadowBias = -.001
    dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
    dir_light.shadowDarkness = .3;
    scene.add(dir_light);
    




    
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;
    renderer.setClearColor( 0x00FFFF );

    document.getElementById('canvas').appendChild( renderer.domElement );

    renderer.render( scene, camera );
    

    pyramid = new THREE.Mesh(
    	new THREE.CylinderGeometry(0,10,7,4,1),
    	new THREE.MeshBasicMaterial({color: 0x00FF77})

    );

    pyramid.receiveShadow = true;
    pyramid.castShadow = true;

    pyramid.rotation.y=Math.PI/4;
    pyramid.geometry.computeVertexNormals();
    scene.add(pyramid);

    visited.push(pyramid.position.x.toString() + ',' + pyramid.position.z.toString());

    recursiveDraw(pyramid,50,visited);

}


function recursiveDraw(obj,n) {
    
    if (n == 0) {
	return;
    }
    
    var pyramid1 = obj.clone();
    pyramid1.geometry.computeBoundingBox();
    pyramid1.position.x += pyramid1.geometry.boundingBox.max.x*1.4;
    if (visited.indexOf(pyramid1.position.x.toString() + ',' + pyramid1.position.z.toString()) < 1) {
	scene.add(pyramid1);
	visited.push(pyramid1.position.x.toString() + ',' + pyramid1.position.z.toString());
	recursiveDraw(pyramid1,n-1);
    }

    var pyramid2 = obj.clone();
    pyramid2.geometry.computeBoundingBox();
    pyramid2.position.z += pyramid2.geometry.boundingBox.max.x*1.4;
    if (visited.indexOf(pyramid2.position.x.toString() + ',' + pyramid2.position.z.toString()) < 1) {
	scene.add(pyramid2);
	visited.push(pyramid2.position.x.toString() + ',' + pyramid2.position.z.toString());
	recursiveDraw(pyramid2,n-1);
    }

    var pyramid3 = obj.clone();
    pyramid3.geometry.computeBoundingBox();
    pyramid3.position.x -= pyramid3.geometry.boundingBox.max.x*1.4;
    if (visited.indexOf(pyramid3.position.x.toString() + ',' + pyramid3.position.z.toString()) < 1) {
	scene.add(pyramid3);
	visited.push(pyramid3.position.x.toString() + ',' + pyramid3.position.z.toString());
	recursiveDraw(pyramid3,n-1);
    }

    var pyramid4 = obj.clone();
    pyramid4.geometry.computeBoundingBox();
    pyramid4.position.z -= pyramid4.geometry.boundingBox.max.x*1.4;
    if (visited.indexOf(pyramid4.position.x.toString() + ',' + pyramid4.position.z.toString()) < 1) {
	scene.add(pyramid4);
	visited.push(pyramid4.position.x.toString() + ',' + pyramid4.position.z.toString());
	recursiveDraw(pyramid4,n-1);
    }


    renderer.render(scene, camera);
}


function animate() {

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

</script>
